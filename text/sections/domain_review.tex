\documentclass[../diploma.tex]{subfiles}
\begin{document} \label{sec:domain_review}

В данной главе будут описаны имеющиеся результаты по теме работы. Сначала будут рассмотрены причины появления и особенности языка 1ML. Затем будут описаны методы, с помощью которых ad-hoc-полиморфизм достигается в некоторых языках. Наконец, будут представлены работы, связанные с добавлением ad-hoc-полиморфизма в языки семейства ML.

\subsection{Модули первого класса и 1ML}

Отсутствие модулей первого класса порождает практические проблемы при попытке интеграции между основным и модульными слоями ML \cite{1ml}. Например, долгое время был невозможен динамический выбор модуля. Классическим примером, представленным в листинге \ref{lst:nicemodules}, является невозможность выбрать реализацию ассоциативного массива в зависимости от числа элементов. Такая функциональность доступна почти в любом объектно-ориентированном языке, поэтому невозможность добиться этого в ML считалась крупным недостатком.

\begin{listing}[H]
\begin{minted}{ocaml}
module Map = if maxElems < 100 then BinTreeMap else HashTableMap 
\end{minted}
\caption{Естественный код для динамического выбора модуля}
\label{lst:nicemodules}
\end{listing}

С целью сделать модули объектами первого класса Руссо предложил дополнить основной язык явной упаковкой и распаковкой модулей (packaged modules) \cite{packaged}. Это предложение было расширено последующими работами \cite{aliceml} \cite{dreyer_thesis} и было реализовано во многих диалектах ML, включая OCaml \cite{packaged_ocaml}. Упаковка и распаковка модулей решает самые остро стоящие практические проблемы, например, позволяя во многих случаях динамически выбирать модуль. Вместе с тем, решение Руссо предполагает наличие множества избыточных типовых аннотаций и недостаточно выразительные типы для некоторых случаев.

\begin{listing}[H]
\begin{minted}{ocaml}
module Map = (val (if maxElems < 100 
                   then (module BinTreeMap : MAP)
                   else (module HashTableMap : MAP))) : MAP)
\end{minted}
\caption{Динамический выбор модуля в OCaml}
\label{lst:badmodules}
\end{listing}

В листинге \ref{lst:badmodules} представлено, как в данный момент можно динамически выбрать модуль. Несмотря на то, что задача решена, этот код выглядит намного менее лаконично и естественно, чем код в листинге \ref{lst:nicemodules}. Что же касается выразительности, приведём пример, ограничивающий использование полиформизма. Типизация полиморфной функции, использующая модули, вынуждена использовать полиморфизм основного языка, например, так:

\begin{minted}{ocaml}
(module S with type t = 'a) -> (module S with type t = 'a) -> 'a
\end{minted}

Тогда как с модулями, которые действительно являются объектами первого класса, можно было бы выразить этот тип следующим образом:
\begin{minted}{ocaml}
(X : S) -> (module S with type t = X.t) -> X.t
\end{minted}

Используя полиморфизм основного языка, попробуем типизировать стандартную функцию \mintinline{ocaml}{return}, принимающую монаду как модуль:
\begin{minted}{ocaml}
return : (module MONAD with type 'a t = ?) -> 'a -> ?
\end{minted}

Так как основной язык не поддерживает полиморфизм высших кайндов, на место вопросов в сигнатуре выше ничего нельзя подставить. 

Таким образом, упаковка и распаковка модулей частично решает проблемы, стоящие перед языком модулей ML, но имеет существенные недостатки. С другой стороны, сложно предложить решение, полностью решающее эти проблемы без существенной переработки основ языка.

Ряд более поздних работ показал, что историческое разделение языка на основной и модульный слои не является обязательным, а также что теория зависимых типов не является обязательной для выражения системы модулей ML. Так, Россберг и другие показали, что все конструкции ML, включая модули, выражаются в рамках Системы F\textsubscript{$\omega$} \cite{fing}. Эти исследования привели к созданию Россбергом экспериментального диалекта 1ML \cite{1ml}, в котором стёрты различия между слоями и поддерживаются модули первого класса в истинном смысле этого выражения. Так, практические проблемы, описанные выше, в 1ML решены. Для обеспечения разрешимости проверки и вывода типов, автор использует идею Харпера~--- Митчела \cite{harper_mitchell} разделения типов на \textit{малые типы} и \textit{большие типы}, накладывая на последние ряд ограничений, например, вывод типов распространяется только на малые типы.  

\subsection{Ad-hoc-полиморфизм}

Термин "ad-hoc-полиморфизм" был предложен Стрэчи в 60-х годах XX века \cite{strachey}. Стрэчи разделяет два вида полиморфизма: \textit{параметрический полиморфизм}, то есть определение функции для разных типов аргументов, на каждых из которых функция работает одинаково, и \textit{ad-hoc-полиморфизм}, в котором функция работает разным образом в зависимости от типов аргументов. Тогда как общепринятым методом для параметрического полиморфизма в функциональных языках стала система типов Хиндли~--- Милнера, долгое время не существовало подходящего метода для ad-hoc-полиморфизма.

Одной из классических работ, решающих эту проблему, стало добавление в язык Haskell \textit{классов типов} \cite{adhoc}, вдохновлённое идеями из объектно-ориентированной парадигмы. Авторы предложили расширение системы типов Хиндли~--- Милнера ad-hoс-полиморфизмом и алгоритм, преобразующий код с классами типов в код без них, в стандартную систему типов Хиндли~--- Милнера. Таким образом, два вида полиморфизма были объединены в единую систему. Рассмотрим классы типов на простом примере.

\begin{listing}[H]
\begin{minted}{haskell}
class Show a where
  show :: a -> String

instance Show Int where
  show = showSignedInt

show_twice x = show x ++ show x
\end{minted}
\caption{Классы типов в Haskell}
\label{lst:haskell}
\end{listing}

В листинге \ref{lst:haskell} определён класс типов \mintinline{haskell}{Show}. Описание этого класса типов состоит из набора функций, в данном случае~--- единственной функции \mintinline{haskell}{show}. Чтобы тип входил в класс типов, для него должны быть определены все эти функции. Эти функции для конкретного типа определяются с помощью создания \textit{экземпляра} (instance) и в дальнейшем могут использоваться как обычные функции. Рассмотрим тип функции \mintinline{haskell}{show_twice}:

\begin{minted}{haskell}
show_twice :: Show a => a -> string
\end{minted}

Эту типизацию следует трактовать следующим образом: функция \mintinline{haskell}{show_twice} имеет тип \mintinline{haskell}{a -> string} для всех \mintinline{haskell}{a}, которые входят в класс типов \mintinline{haskell}{Show}. Важно отметить, что в Haskell используемые классы типов не нуждаются в явном указании, а выводятся из тела функции. Так, в приведённом примере компилятор самостоятельно вывел ограничение \mintinline{haskell}{Show a}, исходя из того, что в теле функции использована функция \mintinline{haskell}{show}.

Похожие на классы типов решения были предложены в ряде других языков, например, в Rust (типажи, traits) \cite{rust}. Важным свойством, выполняющимся для этих решений, является \textit{согласованность} (coherence)~--- каждая корректная типизация программы должна приводить к одной и той же динамической семантике. Решения из этой группы достигают согласованности с помощью \textit{каноничности}~--- для каждого типа и класса типов в текущей области видимости может быть определено не более одного экземпляра. Существуют расширения для Haskell, ослабляющие требования к каноничности, однако эти расширения могут приводить к нарушению согласованности.

Представителем этой группы является Scala и реализованные в ней \textit{неявные аргументы}, также называемые \textit{имплициты} \cite{implicits}. В Scala не требуется каноничность и присутствует возможность явно передать экземпляр, если система типов не способна вывести его самостоятельно. Для неявных аргументов также выполняется согласованность. Чтобы гарантировать согласованность, для каждой функции требуется явно указывать, какие имплициты в ней используются, тогда как в решениях, основанных на классах типов, эта информация была бы выведена автоматически. Пример использования неявных аргументов в Scala приведён в листинге \ref{lst:scala}. Помимо списка обычных параметров, функция может объявить второй список неявных параметров, которые при условии однозначности можно опустить.

\begin{listing}[H]
\begin{minted}{scala}
trait Showable [T] { 
  def show (x: T): String
}

implicit object IntShowable extends Showable [Int] {
  def show (x: Int) = x.toString
}

def show[T](x : T)(implicit s: Showable [T]): String = {
  s.show(x)
}

show(7)(IntShowable)
show(7)
\end{minted}
\caption{Неявные аргументы в Scala}
\label{lst:scala}
\end{listing}

Неявные параметры в разных формах часто встречаются в языках с зависимыми типами. Рассмотрим подробнее Coq, язык, по историческим причинам имеющий много общего с ML. Функциональность, которая в Coq называется неявными параметрами, достаточно примитивна и является скорее аналогом параметрического полиморфизма для языка с зависимыми типами. Ad-hoc-полиморфизм же достигается с помощью двух механизмов: более простых и предсказуемых \textit{канонических структур} \cite{canonical_structures} и более мощных \textit{классов типов} \cite{coq_typeclasses}. Несмотря на название, и классы типов, и канонические структуры в Coq имеют больше общего с неявными аргументами в Scala, чем с классами типов в Haskell. Так, все используемые в функции классы типов следует указывать явно, а каноничность не требуется. Согласованность в Coq не выполняется, но для Coq это не является таким крупным недостатком, как для неинтерактивных языков. Так как Coq в основном используется в контексте автоматических доказательств, в котором достаточно найти любое подходящее доказательство, канонические структуры и классы типов не считают ошибкой неоднозначный вывод неявного параметра~--- вместо этого подставляется любой подходящий.

\begin{listing}[H]
\begin{minted}{ocaml}
module type Show = sig
  type t
  val show : t -> string
end

implicit module Show_int = struct
  type t = int
  let show x = string_of_int x
end

implicit module Show_list {S : Show} = struct
  type t = S.t list
  let show x = string_of_list S.show x
end

let show {S : Show} x = S.show x

show 5 (* show {Show_int} 5 *)
show [1;2;3] (* show {Show_list (Show_int)} [1;2;3] *)
\end{minted}
\caption{Неявные модули в OCaml}
\label{lst:ocaml}
\end{listing}

Вайтом и другими было предложено ввести в OCaml \textit{неявные модули} \cite{white}, решение, вдохновлённое имплицитами из Scala. Именно на этом решении основывается данная работа. Так же как и в Scala, предложение Вайта  не требует каноничности, позволяя в случае неоднозначности явно указывать необходимый параметр, а согласованность достигается с помощью явного указания используемых неявных параметров.

В листинге \ref{lst:ocaml} приведён пример кода, использующего неявные модули для OCaml. Модуль можно аннотировать ключевым словом \mintinline{ocaml}{implicit}, что делает его доступным для поиска неявных аргументов. Функции, принимающей неявный модуль, можно либо передать этот модуль в качестве аргумента, либо опустить его, и модуль будет выведен автоматически. 

Вайтом и другими был реализован прототип, который добавляет в OCaml неявные модули, но в основном языке данная функциональность до сих пор не поддерживается. Реализация полного решения сложна как практически (добавление такой нетривиальной функциональности в столь сложный язык, как OCaml, требует значительной работы), так и теоретически. Основной преградой стала унификация на модульном уровне \cite{discuss}. На данный момент система проверки типов OCaml не поддерживает такую унификацию.

Данная работа основывается именно на работе Вайта и других для реализации неявных модулей в 1ML. Отказ языка 1ML от зависимых типов снимает упомянутые выше проблемы с унификацией. Сравнение также будет осуществлено с работой для OCaml. Существуют также альтернативные предложения для поддержания ad-hoc-полиморфизма в языках семейства ML, но по сравнению с работой Вайта и других они имеют существенные недостатки, которые будут рассмотрены ниже.

\begin{listing}[H]
\begin{minted}{ocaml}
module type SHOW = sig
  type t
  val show : t -> string
end

module F (X : SHOW) = struct
  implicit module S = X
end

implicit module Show_int = struct
  type t = int
  let show = string_of_int
end

module M = struct
  type t = int
  let show _ = "An int"
end

module N = F(M)
\end{minted}
\caption{Пример, демонстрирующий невозможность каноничности в OCaml}
\label{lst:canonicity}
\end{listing}

Как уже было упомянуто, проверка каноничности возможна не во всех языках, включая ML. Система модулей ML позволяет скрывать экземпляры за абстракцией. Рассмотрим, например, следующий код на OCaml, представленный в листинге \ref{lst:canonicity}. В этом примере уже определён экземпляр класса типов \mintinline{ocaml}{SHOW} для типа \mintinline{ocaml}{int}. Тем не менее, посредством модулей скрыт ещё один экземпляр того же класса типов для того же типа, а именно \mintinline{ocaml}{N.S}. Тогда как в данном примере можно определить наличие такого экземпляра, анализируя внутреннюю структуру модулей, это невозможно в общем случае и противоречит самой идее модульности. Аналогичный приведённому пример можно построить и для других языков семейства ML, включая 1ML.

Дрейером и другими были предложены модульные классы типов \cite{ml_typeclasses}, попытка применить классы типов из Haskell в ML. Поскольку в классическом подходе к классам типов требуется каноничность, а в ML невозможно проверить, соблюдается ли она, авторы вводят ряд нежелательных ограничений:

\begin{itemize}
	\item неявные модули могут быть объявлены только на верхнем уровне,
	\item все модули на верхнем уровне должны быть явно типизированы,
	\item на верхнем уровне могут находиться только модули.
\end{itemize}

Эти ограничения только усиливают синтаксическое разделение между модульным и основным слоем, о котором шла речь выше, что особенно нежелательно в 1ML, языке, построенного с целью ослабить это разделение. Помимо этого, модульные классы типов, в отличие от решения Вайта и других, не поддерживают неявные параметры высшего ранга и кайнда, а также классы типов с несколькими параметрами.

Также в нескольких работах были предложены неявные аргументы \cite{experiments} и классы типов \cite{schneider} для ML как независимая от модулей функциональность. Такие решения привносят значительную дубликацию конструкций (так как модульные типы естественно подходят под роль описания классов типов) и не поддерживают продвинутую функциональность, например, параметры высшего кайнда.

\subsection{Выводы и результаты по главе}

Рассмотренны особенности языка 1ML. Изложены с примерами два подхода к поддержанию согласованности: каноничность и указание неявных аргументов. Описано решение Вайта и других, на котором основывается данная работа. Приведены недостатки альтернативных решение для семейства ML: решение Дрейера и других накладывает ограничения в связи с невозможностью проверки каноничности в ML, а решения, не зависящие от системы модулей приводят к дубликации конструкций.

\end{document}