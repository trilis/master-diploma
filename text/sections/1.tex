\documentclass[../diploma.tex]{subfiles}
\begin{document}\label{sec:1}

В данной главе будет даны необходимые определения таких ключевых понятий, как лямбда-исчисление, подстановки и редукции, рассмотрены некоторые классические порядки редукций, такие как нормальный порядок и аппликативный порядок, а также поставлены вопросы относительно оптимальности этих порядков.

\subsection{Редукции термов в лямбда-исчислении}

Лямбда-исчисление \cite{lambda_calculus} --- это математическая система, позволяющая формализовать вычислимость в функциональных языках программирования. Лямбда-исчисление определяется как множество \textit{термов} $T$ вместе с множеством \textit{редукций} $\rightarrow$, описывающих допустимые преобразования термов. В простейшем случае множество термов можно определить как
$$T \ni t ::= \lambda x.\, t \mid x \mid t_1\ t_2$$

Первый случай в этой записи называется \textit{абстракцией} и описывает функцию, принимающую как аргумент некое выражение (переменную) $x$, второй случай описывает обращение к ранее объявленной в абстракции переменной, а третий случай называется \textit{аппликацией} и описывает применение функции к аргументу. Чтобы формально описать семантику лямбда-исчисления, вводятся различные редукции, центральной из которых является \textit{$\beta$-редукция} $\rightarrow_\beta$, формализующая вычисления. Чтобы определить $\beta$-редукцию, введём несколько вспомогательных понятий.

Определим \textit{множество свободных переменных} $FV(t)$ как множество всех переменных в $t$, не имеющих соответствующей абстракции:
$$FV(x) = \{x\},\ FV(t_1\ t_2) = FV(t_1) \cup FV(t_2),\ FV(\lambda x.\, t) = FV(t) \setminus \{x\}$$

Заметим, что переменные в этой системе функционируют как способ связать абстракцию с её аргументом, а конкретные имена этих переменных нам не важны. Чтобы формализовать это наблюдение, определим \textit{$\alpha$-конверсию} как переименование переменной в абстрации на произвольную другую. Согласно конвенции Барендрегта [?], будем неявно применять $\alpha$-конверсию, так чтобы все переменные имели различные имена, а $\alpha$-эквивалентные (т.е. получаемые друг из друга с помощью $\alpha$-конверсии) термы будем считать равными.

Определим \textit{подстановку} $t [x := u]$ как замену всех вхождений переменной $x$ в терме $t$ на терм $u$:
$$x [x := u] = u\ \ \ \ \ \ \ \ y [x := u] = y\ (x \neq y)$$ $$t_1\ t_2 [x := u] = t_1 [x := u]\ t_2 [x := u]$$ $$\lambda x.\, t [x := u] = \lambda x.\, t \ \ \ \ \ \ \ \ (\lambda y.\, t) [x := u] = \lambda y.\, (t [x := u])\ (x \neq y, y \notin FV(u))$$

Заметим, что подстановка для некоторых аргументов может быть не определена из-за условия $y \notin FV(u)$ в последнем случае, но предварительное применение $\alpha$-конверсии для аргумента $u$ с целью использовать в нём только не используемые в $t$ свободные переменные, позволяет доопределить подстановку.

Определим множество \textit{редексов} терма $t$ как множество всех подтермов $t$ вида $(\lambda x.\, t_1) t_2$. Наличие редекса в терме показывает, что в терме есть функция, которую можно применить к аргументу. Наконец, мы можем определить $\beta$-редукцию как подстановку аргумента в произвольном редексе терма, которая оставляет остальную часть терма без изменений:
$$(\lambda x.\, t_1) t_2 \rightarrow_\beta t_2 [x := t_1]$$

Определим $\rightarrow_\beta^*$ как транзитивное замыкание $\rightarrow_\beta$. Если $t_1 \rightarrow_\beta^* t_2$, то будем говорить, что $t_1$ \textit{редуцируется} к $t_2$. Поскольку в терме может быть несколько редексов, \textit{порядок} (или \textit{стратегия}) \textit{редукции}, то есть последовательность редексов в последовательном применении $\beta$-редукции, может быть различным. Этот факт порождает несколько ключевых вопросов: может ли от выбора стратегии зависеть результат, конечность процесса, и, наконец, оптимальность (т.е. количество шагов редукции).

Будем говорить, что терм $t$ находится в \textit{нормальной форме}, если к нему нельзя применить $\beta$-редукцию, то есть он не содержит редексов. Нормальная форма представляет собой конечный результат вычислений, подобно упрощенной до конкретного числа арифметической формуле. Важным свойством любой системы, основанной на лямбда-исчислении, является \textit{конфлюэнтность}, то есть независимость результата от порядка редукций:
$$t_1 \rightarrow_\beta^* t_1',\ t_2 \rightarrow_\beta^* t_2' \ \Rightarrow\ \exists t.\ t_1' \rightarrow_\beta^* t,\ t_2' \rightarrow_\beta^* t$$

Напрямую из определения конфлюэнтности следует, что если система является конфлюэнтной, то терм не может редуцироваться к разным нормальным формам. Описанная выше простейшая система лямбда-исчисления является конфлюэнтной[?], как и многие другие более сложные и применимые на практике системы, поскольку недетерминированные в этом смысле системы являются менее желательными на практике. Будем называть терм $t'$ \textit{нормальной формой} терма $t$, если $t'$ находится в нормальной форме, а $t$ редуцируется к $t'$. Задача поиска нормальной формы является ключевой при разработке семантики любого функционального языка программирования, поскольку, в практических терминах, решение этой задачи эквивалентно написанию интерпретатора языка. 

Для ответа на вопрос о завершимости введём понятия \textit{сильной} и \textit{слабой нормализуемости}. Терм $t$ является слабо нормализуемым, если у него есть нормальная форма, и сильно нормализуемым, если любая стратегия редукции редуцирует его к нормальной форме за конечное число шагов $\beta$-редукции. Система является сильно (слабо) нормализуемой, если все термы в ней являются сильно (слабо) нормализуемыми.

Описанная выше простейшей системе лямбда-исчисления не является ни сильно, ни слабо нормализуемой [?]. На практике это означает, что вычисление кода, соответствующего некоторым термам, может не завершиться, что в некоторых случаях нежелательно (а в слабом случае --- завершимость этого вычисления может зависеть от порядка редукций). Данную проблему можно решать \textit{типизацией} термов, т.е. рассмотрением только подмножества в каком-то смысле корректных термов. Так, просто типизированное лямбда-исчисление [?] является сильно нормализуемым, однако в такой системе становится невозможно описать рекурсию. Более того, любой полный по Тьюрингу язык не может быть сильно нормализуемым [?].

Данная работа находится в контексте системы, которая является и конфлюэнтной, и сильно нормализуемой (см. ниже в ...), то есть независимо от выбора стратегии редукции, любое вычисление придёт к единственно верному результату за конечное число шагов. Нас же интересует вопросы \textit{оптимальности} стратегий, поскольку даже в системе, удовлетворяющим описанным выше теоретическим свойствам, термы могут редуцироваться к начальной форме за существенно отличающееся и значимое на практике число шагов.

\subsection{Классические порядки редукций}

Мы рассмотрим два классических порядка редукций --- нормальный и аппликативный, 

\subsection{Выводы и результаты по главе}

TODO

\end{document}
