\documentclass[../diploma.tex]{subfiles}
\begin{document}\label{sec:1}

В данной главе будет описаны синтаксис и семантика для новой функциональности на примере модулей, отвечающих за строковое представление данных различных типов, а затем дано высокоуровневое описание алгоритма, осуществляющего вывод неявных модулей.

\subsection{Описание синтаксиса и семантики}

Для начала опишем, какие новые конструкции языка вносит в 1ML данная работа. Чтобы задать функцию с неявным параметром, неявный параметр нужно обернуть в квадратные скобки и явно протипизировать:

\begin{minted}{ocaml}
type SHOW = {
    type t
    show : t -> text
}

show [S: SHOW] x = S.show x
show_fun = fun [S : SHOW] x => S.show x
\end{minted}

Неявный модуль будет строиться, используя доступные в области видимости переменные, объявленные неявными с помощью ключевого слова \mintinline{ocaml}{implicit}. Множество таких переменных будем в дальнейшем называть \textit{неявной областью видимости}.

\begin{minted}{ocaml}
implicit Show_int = {
    type t = int
    show = primitive "Int.toText"
}
\end{minted}

Заметим, что при объявлении модуля \mintinline{ocaml}{Show_int} не требуется явно указывать, что он удовлетворяет интерфейсу \mintinline{ocaml}{SHOW}, как бы это, например, понадобилось в Scala или Haskell. Такое возможно из-за того, что в языках семейства ML используется структурная подтипизация.

Ключевым словом \mintinline{ocaml}{implicit} можно аннотировать любое объявление переменной. В том числе, можно уже объявленный модуль внести в неявную область видимости следующим кодом:

\begin{minted}{ocaml}
Bool_to_string = {
    type t = bool
    show x = if x then "true" else "false"
}

implicit Show_bool = Bool_to_string
\end{minted}

\textit{Функтором} в ML называется модуль, параметризуемый другим модулем. Функтор, который помечен ключевым словом \mintinline{ocaml}{implicit} и имеет только неявные аргументы называется \textit{неявным функтором}:

\begin{minted}{ocaml}
implicit Show_list [S: SHOW] = {
    type t = list S.t
    show x = "[" ++ (toText S.show x) ++ "]"
}
\end{minted}

Применение функции \mintinline{ocaml}{show} возможно двумя способами: с явным указанием модуля и с неявным. В первом случае желаемый модуль оборачивается в квадратные скобки, во втором не указывается вовсе. Ниже будем называть вызов функции с пропущенными неявными аргументами \textit{неявной аппликацией}. Так же как в решении для OCaml, в данной работе неявную аппликацию можно применить только в случае, если существует единственный модуль, который можно подставить, в противном случае компиляция завершится с ошибкой "неоднозначность". В случае, если есть несколько подходящих модулей, выбор между ними следует осуществить явно. Таким образом, в данной работе представлено решение, для которого верна согласованность, но не обязательна каноничность. Следующие два вызова будут семантически эквивалентны:

\begin{minted}{ocaml}
show [Show_int] 5
show 5
\end{minted}

А если вызвать функцию \mintinline{ocaml}{show}, передав ей список чисел, то подставится \\ \mintinline{ocaml}{Show_list [Show_int]}, то есть следующие два вызова эквивалентны:

\begin{minted}{ocaml}
show [Show_list [Show_int]] (1 :: (2 :: (3 :: nil)))
show (1 :: (2 :: (3 :: nil)))
\end{minted}

Локальные переменные могут быть также объявлены в качестве неявных:

\begin{minted}{ocaml}
let implicit Show_int = {
    type t = int
    show = primitive "Int.toText"
} in let implicit Show_list [S: SHOW] = {
    type t = list S.t
    show x = "[" ++ (toText S.show x) ++ "]"
} in show (1 :: (2 :: (3 :: nil)))
\end{minted}

Синтаксис в данной работе довольно близко следует за синтаксисом из \cite{white}, это сделано намеренно~--- с целью упростить сравнение мощности решений. Единственное существенное синтаксическое различие заключается в добавлении в этой работе синтаксической формы \mintinline{ocaml}{[_]}. Её можно использовать, чтобы явно указать место, где должен быть вставлен неявный модуль:

\begin{minted}{ocaml}
show [_] 5
\end{minted}

Мотивация для добавления этой конструкции будет описана в параграфе \ref{underscore}.

\subsection{Общая схема алгоритма}

Вывод неявных модулей производится на основе типов, которые должны иметь эти модули. То есть, чтобы определить, какой модуль необходимо неявно вывести, требуется вначале определить тип этого модуля. 

Рассмотрим, как выглядят такие типы, для примера снова возьмём функцию \mintinline{ocaml}{show}. Напомним её определение:

\begin{minted}{ocaml}
show [S: SHOW] x = S.show x
\end{minted}

И протипизируем её:

\begin{minted}[escapeinside=||]{ocaml}
show : [S : SHOW] -> S.t -> text
\end{minted}

Применение такой функции, например, к переменной типа \mintinline{ocaml}{int} инстанциирует \\\mintinline{ocaml}{S.t = int}, то есть модуль будет искаться по типу \mintinline{ocaml}{SHOW with t = int}, что уже (при условии, что есть только одно строковое представление для \mintinline{ocaml}{int}) однозначно определяет модуль.

Не всегда тип неявного модуля известен заранее, так как он может зависеть от ещё невыведенных типов. Рассмотрим, например, такую функцию:

\begin{minted}{ocaml}
f x = Text.print (show x); x + 5
\end{minted}

Изначально \mintinline{ocaml}{x} типизируется как некоторая переменная вывода типов \mintinline{ocaml}{α}. Если вывод неявного модуля будет запущен до обработки подвыражения \mintinline{ocaml}{x + 5}, то поиск модуля будет производиться по типу \mintinline{ocaml}{SHOW with t = α} и потерпит неудачу, ведь каждый модуль типа \mintinline{ocaml}{SHOW} удовлетворяет такому типу. Если же подвыражение \mintinline{ocaml}{x + 5} уже будет типизировано, то полученное уравнение \mintinline{ocaml}{α = int} позволит однозначно вывести корректный модуль.

Данный пример демонстрирует, что вывод неявных модулей зависит от вывода типов. Верно и обратное. Например, пусть есть только одна реализация типа модулей \mintinline{ocaml}{SINGLE}, имеющая тип \mintinline{ocaml}{SINGLE with t = int}. Тогда поиск неявного модуля по типу \mintinline{ocaml}{SINGLE with t = α} приведёт к унификации \mintinline{ocaml}{α = int}.

Можно предположить, что, раз вывод неявных модулей зависит от вывода типов, который в свою очередь, зависит от вывода неявных модулей, то вывод одних неявных модулей может зависеть от вывода других неявных модулей. Это действительно так, и обсуждению проблем, связанных с этим, посвящена глава \ref{sec:3}.

Так как вывод неявных модулей и вывод типов взаимно зависимы, нельзя завершить одно раньше начала другого, необходимо выполнять эти процессы в одной фазе компиляции. В существующем компиляторе 1ML проверка типов, вывод типов и преобразование в Систему F\textsubscript{$\omega$} осуществляются одним проходом по синтаксическому дереву. Соответственно, вывод неявных типов будет добавлен к этому проходу.

Простым решением, которое и было реализовано в первую очередь, было бы выводить неявный модуль в момент обработки неявной аппликации. Но, как было проиллюстрированно рассуждениями выше, в этот момент некоторые типы могут быть ещё не выведены, и для вывода модуля не хватит информации. На практике такое решение оказалось почти бесполезным.

Чтобы выводить модули в момент, в который про их типы будет известно больше информации, будем откладывать вывод модулей и выводить несколько модулей за раз. Обрабатывая неявную аппликацию, вставим вместо модуля специальную \textit{неявную переменную} с уникальным именем. Значение этой переменной будет определено позднее. А вот её тип уже известен, правда, он может быть не полностью выведен, то есть зависеть от нескольких переменных вывода типов. Поэтому проверка типов останется корректной после добавления такой фиктивной переменной. 

После добавления неявной переменной продолжается типизация кода и его преобразование в Систему F\textsubscript{$\omega$}, в процессе чего некоторые из переменных вывода типов, связанных с типами неявных переменных, могут быть выведены. Затем в некоторый момент (точное место этого момента будет определёно ниже, в параграфе \ref{time}) запускается поиск модулей для накопившихся неявных переменных. В случае успеха неявные переменные заменяются на термы Системы F\textsubscript{$\omega$}, соответствующие найденным модулям, а их типы окончательно выводятся, если не были выведены до этого.

Перейдём теперь к описанию непосредственно поиска модулей по типу\footnote{Эта функциональность реализована в файле implicitsearch.ml, в функции \href{https://github.com/trilis/1ml/blob/5b850e875e9ae06d3ce8e90a22cedbabcf0f33ca/implicitsearch.ml\#L102}{implicit\_search}. Здесь и далее ссылки на реализацию даются на репозиторий \href{https://github.com/trilis/1ml}{github.com/trilis/1ml}}. Заметим, что при наличии в неявной области функторов, которые принимают в качестве аргументов другие модули, число модулей, которые могут быть подставлены, бесконечно. Поэтому решение, перебирающее всех возможных кандидатов и сравнивающее их тип с нужным, не будет завершаться.

В связи с этим будем выводить модуль рекурсивно, поддерживая множество ограничений на тип, и проверять модуль на соответствие ограничениям с помощью отношения подтипизации. Псевдокод для поиска модулей по типу приведён в алгоритме \ref{algo:search}. Для примера рассмотрим вызов \mintinline{ocaml}{show (1 :: (2 :: (3 :: nil)))}. Из контекста будет определено, что необходимо найти модуль с типом \mintinline{ocaml}{SHOW with}\\\mintinline{ocaml}{t = list int}. Функтор \mintinline{ocaml}{Show_list} имеет тип \mintinline{ocaml}{[S : SHOW] -> SHOW with t = list S.t}. Чтобы проверить, подходит ли он под требуемые ограничения, проверим, является ли \mintinline{ocaml}{list S.t} подтипом \mintinline{ocaml}{list int}. Это верно, если \mintinline{ocaml}{S.t = int}, поэтому выполним такую унификацию и запустимся рекурсивно. Чтобы вывести аргумент функтора, нужно найти модуль с типом \mintinline{ocaml}{SHOW with t = int}, чему удовлетворяет модуль \mintinline{ocaml}{Show_int}. Таким образом, ответ~--- \mintinline{ocaml}{Show_list [Show_int]}.

В результате поиск модулей либо корректно завершается, возвращая нужный модуль, либо возвращает одну из трёх ошибок: "нет кандидатов", "неоднозначность" (то есть нашлось несколько подходящих кандидатов) или "поиск не завершается" (чему будет посвящён параграф \ref{termination}).

\begin{megaalgorithm}\captionsetup{labelfont={sc,bf}, labelsep=newline}
  \caption{Поиск подходящего модуля}
  \label{algo:search}
\begin{algorithmic}
\Function{search\_helper}{constraints}
\State $candidates \gets \varnothing$
\For{$module$~\textbf{in} неявная область видимости}
    \If{$module$~--- функтор}
        \State $argTypes \gets \textnormal{типы аргументов функторов}$
        \State $resType \gets \textnormal{тип возвращаемого значения функтора}$
        \If{$resType$ удовлетворяет $constraints$}
            \State $type \gets \textnormal{тип, построенный по~} constraints$
            \State $unify(type, resType)$
            \State $candidates \gets candidates \cup \{search\_args(argTypes)\}$
        \EndIf
    \Else
        \If{$type(module)$ удовлетворяет $constraints$}
            \State $candidates \gets candidates \cup \{module\}$
        \EndIf
    \EndIf
\EndFor
\State \Return $candidates$
\EndFunction

\Function{search\_args}{argTypes, head}
\If{$argTypes = \varnothing$}
    \State \Return $head$
\EndIf
\State $result \gets \varnothing$
\State $argType, otherArgTypes \gets argTypes$
\State $candidates \gets search\_helper(generate\_constraints(argType))$
\For{$candidate$~\textbf{in} $candidates$}
    \State $argType', otherArgTypes' \gets copy(argType, otherArgTypes)$
    \State $unify(argType', type(candidate))$
    \State $result \gets result \cup search\_args(otherArgTypes', head~@~candidate)$
\EndFor
\State \Return $results$
\EndFunction

\Function{search}{type}
    \State $constraints \gets generate\_constraints(type)$
    \State $candidates \gets search\_helper(constraints)$
    \If{$|candidates| = 0$}
        \State \Return ошибка "нет кандидатов"
    \ElsIf{$|candidates| > 1$}
        \State \Return ошибка "неоднозначность"
    \Else
        \State $candidate \gets \textnormal{единственный элемент в~} candidates$
        \State $unify(type, type(candidate))$
        \State \Return $candidate$
    \EndIf
\EndFunction
\end{algorithmic}
\end{megaalgorithm}

\subsection{Выводы и результаты по главе}

Синтаксис решения повторяет предложенный для OCaml, за исключением добавления синтаксической формы \mintinline{ocaml}{[_]}. Вывод модулей и вывод типов тесно связаны между собой. Дойдя до неявной аппликации, подставим неявную переменную с неизвестным типом. Будем откладывать вывод модулей, чтобы получить больше информации из вывода типов. Чтобы найти модуль по типу, перебираются все модули и сравниваются с помощью подтипизации, аргументы функторов выводятся рекурсивно.

\end{document}
