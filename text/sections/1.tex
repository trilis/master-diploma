\documentclass[../diploma.tex]{subfiles}
\begin{document}\label{sec:1}

В данной главе будет даны необходимые определения таких ключевых понятий, как лямбда-исчисление, подстановки и редукции, рассмотрены некоторые классические порядки редукций, такие как нормальный порядок и аппликативный порядок, а также поставлены вопросы относительно оптимальности этих порядков.

\subsection{Редукции термов в лямбда-исчислении}

Лямбда-исчисление \cite{lambda_calculus} --- это математическая система, позволяющая формализовать вычислимость в функциональных языках программирования. Лямбда-исчисление определяется как множество \textit{термов} $T$ вместе с множеством \textit{редукций} $\rightarrow$, описывающих допустимые преобразования термов. В простейшем случае множество термов можно определить как
$$T \ni t ::= \lambda x.\, t \mid x \mid t_1\ t_2$$

Первый случай в этой записи называется \textit{абстракцией} и описывает функцию, принимающую как аргумент некое выражение (переменную) $x$, второй случай описывает обращение к ранее объявленной в абстракции переменной, а третий случай называется \textit{аппликацией} и описывает применение функции к аргументу. Чтобы формально описать семантику лямбда-исчисления, вводятся различные редукции, центральной из которых является \textit{$\beta$-редукция} $\rightarrow_\beta$, формализующая вычисления. Чтобы определить $\beta$-редукцию, введём несколько вспомогательных понятий.

Определим \textit{множество свободных переменных} $FV(t)$ как множество всех переменных в $t$, не имеющих соответствующей абстракции:
$$FV(x) = \{x\},\ FV(t_1\ t_2) = FV(t_1) \cup FV(t_2),\ FV(\lambda x.\, t) = FV(t) \setminus \{x\}$$

Заметим, что переменные в этой системе функционируют как способ связать абстракцию с её аргументом, а конкретные имена этих переменных нам не важны. Чтобы формализовать это наблюдение, определим \textit{$\alpha$-конверсию} как переименование переменной в абстрации на произвольную другую. Согласно конвенции Барендрегта [?], будем неявно применять $\alpha$-конверсию, так чтобы все переменные имели различные имена, а $\alpha$-эквивалентные (т.е. получаемые друг из друга с помощью $\alpha$-конверсии) термы будем считать равными.

Определим \textit{подстановку} $t [x := u]$ как замену всех вхождений переменной $x$ в терме $t$ на терм $u$:
$$x [x := u] = u\ \ \ \ \ \ \ \ y [x := u] = y\ (x \neq y)$$ $$t_1\ t_2 [x := u] = t_1 [x := u]\ t_2 [x := u]$$ $$\lambda x.\, t [x := u] = \lambda x.\, t \ \ \ \ \ \ \ \ (\lambda y.\, t) [x := u] = \lambda y.\, (t [x := u])\ (x \neq y, y \notin FV(u))$$

Заметим, что подстановка для некоторых аргументов может быть не определена из-за условия $y \notin FV(u)$ в последнем случае, но предварительное применение $\alpha$-конверсии для аргумента $u$ с целью использовать в нём только не используемые в $t$ свободные переменные, позволяет доопределить подстановку.

Определим множество \textit{редексов} терма $t$ как множество всех подтермов $t$ вида $(\lambda x.\, t_1) t_2$. Наличие редекса в терме показывает, что в терме есть функция, которую можно применить к аргументу. Наконец, мы можем определить $\beta$-редукцию как подстановку аргумента в произвольном редексе терма, которая оставляет остальную часть терма без изменений:
$$(\lambda x.\, t_1) t_2 \rightarrow_\beta t_2 [x := t_1]$$

Определим $\rightarrow_\beta^*$ как транзитивное замыкание $\rightarrow_\beta$. Если $t_1 \rightarrow_\beta^* t_2$, то будем говорить, что $t_1$ \textit{редуцируется} к $t_2$. Поскольку в терме может быть несколько редексов, \textit{порядок} (или \textit{стратегия}) \textit{редукции}, то есть последовательность редексов в последовательном применении $\beta$-редукции, может быть различным. Этот факт порождает несколько ключевых вопросов: может ли от выбора стратегии зависеть результат, конечность процесса, и, наконец, оптимальность (т.е. количество шагов редукции).

Будем говорить, что терм $t$ находится в \textit{нормальной форме}, если к нему нельзя применить $\beta$-редукцию, то есть он не содержит редексов. Нормальная форма представляет собой конечный результат вычислений, подобно упрощенной до конкретного числа арифметической формуле. Важным свойством любой системы, основанной на лямбда-исчислении, является \textit{конфлюэнтность}, то есть независимость результата от порядка редукций:
$$t_1 \rightarrow_\beta^* t_1',\ t_2 \rightarrow_\beta^* t_2' \ \Rightarrow\ \exists t.\ t_1' \rightarrow_\beta^* t,\ t_2' \rightarrow_\beta^* t$$

Напрямую из определения конфлюэнтности следует, что если система является конфлюэнтной, то терм не может редуцироваться к разным нормальным формам. Описанная выше простейшая система лямбда-исчисления является конфлюэнтной[?], как и многие другие более сложные и применимые на практике системы, поскольку недетерминированные в этом смысле системы являются менее желательными на практике. Будем называть терм $t'$ \textit{нормальной формой} терма $t$, если $t'$ находится в нормальной форме, а $t$ редуцируется к $t'$. Задача поиска нормальной формы является ключевой при разработке семантики любого функционального языка программирования, поскольку, в практических терминах, решение этой задачи эквивалентно написанию интерпретатора языка. 

Для ответа на вопрос о завершимости введём понятия \textit{сильной} и \textit{слабой нормализуемости}. Терм $t$ является слабо нормализуемым, если у него есть нормальная форма, и сильно нормализуемым, если любая стратегия редукции редуцирует его к нормальной форме за конечное число шагов $\beta$-редукции. Система является сильно (слабо) нормализуемой, если все термы в ней являются сильно (слабо) нормализуемыми.

Описанная выше простейшей системе лямбда-исчисления не является ни сильно, ни слабо нормализуемой [?]. На практике это означает, что вычисление кода, соответствующего некоторым термам, может не завершиться, что в некоторых случаях нежелательно (а в слабом случае --- завершимость этого вычисления может зависеть от порядка редукций). Данную проблему можно решать \textit{типизацией} термов, т.е. рассмотрением только подмножества в каком-то смысле корректных термов. Так, просто типизированное лямбда-исчисление [?] является сильно нормализуемым, однако в такой системе становится невозможно описать рекурсию. Более того, любой полный по Тьюрингу язык не может быть сильно нормализуемым [?].

Данная работа находится в контексте системы, которая является и конфлюэнтной, и сильно нормализуемой (см. ниже в ...), то есть независимо от выбора стратегии редукции, любое вычисление придёт к единственно верному результату за конечное число шагов. Нас же интересует вопросы \textit{оптимальности} стратегий, поскольку даже в системе, удовлетворяющим описанным выше теоретическим свойствам, термы могут редуцироваться к начальной форме за существенно отличающееся и значимое на практике число шагов.

\subsection{Классические порядки редукций}

Мы рассмотрим два классических порядка редукций --- нормальный и аппликативный. 

\textit{Аппликативный} порядок редукции заключается в выборе наиболее вложенного редекса (а из редексов с равной вложенностью --- самого левого). При таком порядке все аргументы абстракции будут вычислены до того, как подставлены. \textit{Нормальный} порядок редукции, также называемый \textit{вызов по имени} (\textit{call-by-name}) заключается в выборе наименее вложенного редекса (аналогично, из редексов с равной вложенностью выбирается самый левый).

При условии наличия у терма нормальной формы нормальный порядок всегда редукцирует терм к ней, чего нельзя сказать про аппликативный порядок. Например, для терма $(\lambda x.\, y) (\omega \omega)$, где $y$ --- свободная переменная, а $\omega = \lambda z.\, z z$, нормальный порядок редуцирует внешний редекс, придя к нормальной форме $y$, а аппликативный порядок будет бесконечно редуцировать редекс $\omega \omega$, который редуцируется к себе же. Но даже в сильно нормализуемых системах производительность этих порядков на некоторых примерах может существенно отличаться.

В целом, преимущество нормального порядка по сравнению с аппликативным заключается в отбрасывании веток вычисления, которые не будут использованы в итоговом вычислении. Интуитивно, нормальный порядок является ленивым, то есть не будет вычислять аргументы абстракций до того, как они непосредственно понадобятся. Это позволяет ему не вычислять ветки вычисления, которые не используются в итоге, как и было проиллюстрированно в примере выше. На практике такие неиспользуемые ветки вычисления могут соответствовать, к примеру, проекциям структуры (в этом случае вычисления в полях, не задействованных в проекции, становятся бесполезными), или условным операторам с константным условием.

Недостатком же нормального порядка является возможное дублирование подтермов при подстановке, и, соответственно, дубликация работы при редукции этих подтермов. Для примера рассмотрим терм $\omega ((\lambda y.\, y) x)$: $$\omega ((\lambda y.\, y) x) \rightarrow_{\beta_{appl}} \omega x \rightarrow_{\beta_{appl}} x x$$ $$ \omega ((\lambda y.\, y) x) \rightarrow_{\beta_{norm}} ((\lambda y.\, y) x) ((\lambda y.\, y) x) \rightarrow_{\beta_{norm}} x ((\lambda y.\, y) x) \rightarrow_{\beta_{norm}} x x$$

В нормальном порядке из-за преждевременной подстановки не приведённого к нормальной форме подтера $((\lambda y.\, y) x)$ оказались удвоенными вычисления, направленные на редукцию этого терма. А если рассмотреть редукцию терма $\underbrace{\omega\omega\cdots\omega\,}_\text{$n$ раз}((\lambda y.\, y) x)$, то редукция в нормальном порядке повторит редукцию этого подтерма $2^n$ раз, то есть в таких случаях нормальный порядок будет экспоненциально менее производительным, чем аппликативный.

Чтобы решить эту проблему, в некоторых языках, например в Haskell [?], вводится мемоизация для результатов редукции подтермов, то есть результат однажды редуцированного подтерма используется при редукции его копий. Такая модификация нормального порядка называется \textit{вызов по необходимости} (\textit{call-by-need}). Такие техники могут быть достаточными сложными алгоритмами, добавляющими определённые накладные расходы на производительность и использование памяти, поэтому они используются не всегда, однако они решают описанное выше экспоненциальное замедление.

TODO call-by-value модификации

TODO в каких языках используются какие порядки

\subsection{Исчисление конструкций и Coq}

TODO

\subsection{Система Ursus}

Система Ursus разработана как расширение системы Coq и предназначена для верификации смарт-контрактов на различных языках. Она включает в себя:
\begin{itemize}
    \item внутренний монадический язык;
    \item транслятор, позволяющий автоматически получать из исходного кода смарт-контрактов на языках Solidity, Rust, FunC аналогичный код на внутреннем языке Ursus;
    \item аналоги стандартных библиотек для этих языков, сформулированных на Coq или Ursus, с заранее доказанными фактами о содержимом этих библиотек;
    \item интерпретатор для языка Ursus;
    \item \textit{генератор вычислений} (\textit{exec generator}), повзоляющий преобразовывать TODO;
    \item язык для написания спецификаций;
    \item алгоритм, который позволяет упростить символьное вычисление, полученное из генератора вычислений, относительно конкретного элемента спецификации, тем самым упростив работу верификатора.
\end{itemize}

Эта работа посвящена оптимизации последнего пункта, а в этом разделе будут коротко объяснены детали других шагов для понимания контекста.

\subsection{Выводы и результаты по главе}

TODO

\end{document}
