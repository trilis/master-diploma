\documentclass[../diploma.tex]{subfiles}
\begin{document} \label{sec:introduction}

\textit{Ad-hoc-полиморфизм}~--- это свойство языка программирования, позволяющее создать функцию, семантика которой будет зависеть от типов входных параметров. В качестве примеров таких функций можно назвать функцию \mintinline{ocaml}{print}, позволяющую выводить значения различных типов, и оператор \mintinline{ocaml}{+}, позволяющий складывать как целые числа, так и числа с плавающей точкой, а в некоторых языках также и строки. Ad-hoc-полиморфизм позволяет программисту писать более лаконичный код, улучшает читаемость кода, а также способствует парадигме обобщённого программирования.

В процедурных и объектно-ориентированных языках классическим методом реализации ad-hoc-полиморфизма является \textit{перегрузка} функций и операторов. К сожалению, этот простой метод не подходит для языков с мощным выводом типов и строгой системой типов, так как в них не всегда можно однозначно выбрать перегрузку в месте вызова функции. Для таких языков были разработаны более сложные методы, а некоторые языки до сих пор не поддерживают ad-hoc-полиморфизм.

Эта работа посвящена исследованию способов поддержки ad-hoc-полиморфизма в языках семейства ML. Эти языки широко применяются в таких областях, как создание компиляторов, автоматическое доказательство теорем, анализ кода, финансовая сфера и веб-разработка. ML-подобные языки ведут свою историю с 1973 года и оказали влияние на развитие таких популярных языков, как C++, Scala, Rust, Haskell и другие.

Одним из существенных недостатков языков из семейства ML является отсутствие ad-hoc-полиморфизма. Так, в стандартную библиотеку языка OCaml, одного из самых популярных диалектов ML, включено множество функций для вывода значений различных типов: \mintinline{ocaml}{print_int}, \mintinline{ocaml}{print_float}, \mintinline{ocaml}{print_string} и так далее, а также отдельные операторы \mintinline{ocaml}{+} и \mintinline{ocaml}{+.}, для сложения целых чисел и чисел с плавающей точкой, соответственно. Так как ML-подобные языки знамениты мощным выводом типов, который позволяет ставить меньше явных типовых аннотаций и писать обобщённый код, такая избыточность идёт вразрез с философией языка.

Исследователями было предложено несколько работ, вносящих ad-hoc-полиморфизм в языки семейства ML. Работа Вайта \cite{white}, вводящая \textit{неявные модули} для языка OCaml, предлагает наиболее мощную функциональность по сравнению с аналогами \cite{ml_typeclasses} \cite{experiments} \cite{schneider}, и именно этот метод послужит основанием для данной работы. Тем не менее, полноценное введение этого метода в OCaml требует значительной практической и теоретической работы. Так, система проверки типов (type checker) OCaml в данный момент не поддерживает в общем случае унификацию на уровне модулей, которая необходима для работы этого метода \cite{discuss}.

Помимо мощного вывода типов, ML-подобные языки также отличаются продвинутой \textit{системой модулей}, основанной на теории зависимых типов \cite{dependent_types}. Тогда как обе эти технологии успешно используются программистами, они существуют независимо друг от друга. Так, язык ML по историческим причинам фактически поделён на два слоя. Во внутреннем, основном слое действует вывод типов, тогда как во внешнем, модульном слое поддерживаются более выразительные типы, в обмен на их явное объявление и общую избыточность. Интеграция между этими слоями затруднена, так как модули не являются объектами первого класса. Было предложено несколько решений этой проблемы \cite{packaged} \cite{aliceml} \cite{packaged_ocaml}, но они порождают избыточный код и не поддерживают некоторые случаи.

Экспериментальный язык 1ML \cite{1ml} был создан для решения проблем системы модулей. Он предлагает минималистичный и единообразный подход к данной проблеме, стирая синтаксическое разделение между основным и модульным слоями, взамен предлагая более тонкое семантическое разделение. Предположительно, такой подход позволит добавить в язык многие важные модели, реализация которых при традиционном подходе к модулям считались затруднительными, включая, например, поддержку ad-hoc-полиморфизма.

\subsection*{Цель и задачи}

Целью данной работы является поддержка ad-hoc-полиморфизма в языке 1ML, подобная неявным модулям из \cite{white}, но при этом предлагающая более полное решение в аспектах, касающихся порядка разрешения неявных модулей и поддержки неявных функторов. Для этого ставятся следующие задачи:

\begin{itemize}
	\item Реализация неявных модулей для языка 1ML, повторяющих функциональность решения для OCaml;
	\item Разработка алгоритма, позволяющего полно и эффективно осуществлять вставку неявных модулей;
	\item Поддержка неявных аргументов для функторов;
	\item Сравнение с существующим решением \cite{white} для OCaml.
\end{itemize}

\subsection*{Обзор последующих глав}

Глава \ref{sec:domain_review} посвящена обзору существующих статей и результатов, относящихся к области исследования. 

В главе \ref{sec:1} описываются предложенный синтаксис, семантика и общая схема алгоритма.

Глава \ref{sec:2} содержит описание важных деталей решения и даёт обоснование выборов при дизайне алгоритма.

В главе \ref{sec:3} обсуждаются проблемы, возникающие при предопределённом порядке разрешения неявных аргументов, и предлагается алгоритм, позволяющий эффективно решить эти проблемы.

\end{document}