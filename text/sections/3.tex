\documentclass[../diploma.tex]{subfiles}
\begin{document}\label{sec:3}

Данная глава посвящена исследованию влияния, которое выбор порядка вывода модулей оказывает на корректность алгоритма. Вначале будет представлены на примерах недостатки решения для OCaml, а затем будет представлен алгоритм, лишённый этих недостатков, а также описаны оптимизации и эвристики к этому алгоритму и анализ его сложности.

\subsection{Анализ проблемы}

Как уже было упомянуто в главе \ref{sec:1}, вывод одних неявных модулей может зависеть от вывода других неявных модулей. То есть, на некоторых примерах успешность вывода модулей зависит от порядка, в котором они будут обрабатываться. Эта работа уделяет особое внимание исследованию таких примеров.

\begin{listing}[H]
\begin{minted}{ocaml}
module type PLUS = sig
  type t and u and res
  val ( + ) : t -> u -> res
end;;

let ( + ) {P : PLUS} = P.( + );;

implicit module Float_Float = struct
  type t = float and u = float and res = float
  let ( + ) = ( +. )
end;;

implicit module Int_Float = struct
  type t = int and u = float and res = float
  let ( + ) l r = (float_of_int l) +. r
end;;

(* Аналогично объявленные Int_Int и Float_Int опущены для краткости *)

print_float ((1 + 1.1) + 2.5);;
\end{minted}
\caption{Пример кода на OCaml, который не работает из-за некорректного порядка вывода}
\label{lst:order}
\end{listing}

Проиллюстрируем важность этой проблемы на достаточно простом коде, приведённый в листинге \ref{lst:order}. Этот код реализует возможность смешения чисел типа \mintinline{ocaml}{int} и \mintinline{ocaml}{float} при сложении: например, \mintinline{ocaml}{1 + 1.1}. В рамках этой работы было обнаружено, что, несмотря на свою простоту, данный код не будет работать в решении для OCaml.

В листинге \ref{lst:order} определяется перегрузка оператора \mintinline{ocaml}{+} для всех возможных комбинаций из \mintinline{ocaml}{int} и \mintinline{ocaml}{float}. Прототип неявных модулей для OCaml выдаст ошибку "неоднозначность" на последней строчке. Дело в том, что в решении для OCaml модули обрабатываются в следующем порядке: неявный аргумент в функции будет выведен до того, как будут выведены неявные аргументы в других аргументах этой функции. Так, в выражении \mintinline{ocaml}{(1 + 1.1) + 2.5} первым будет выведен неявный аргумент для второго плюса. Так как первый плюс ещё не обработан, тип выражения \mintinline{ocaml}{1 + 1.1} ещё не выведен, поэтому второй плюс имеет тип \mintinline{ocaml}{α -> float -> float}. Такому типу соответствуют и \mintinline{ocaml}{Float_Float}, и \mintinline{ocaml}{Int_Float}. Если бы первый плюс обрабатывался первым, то оба неявных аргумента были бы корректно выведены.

Этот конкретный пример был бы обработан корректно, если предложить обратный принятому в OCaml порядку вывода: выводить сначала неявные аргументы в аргументах неявной функции, и лишь потом неявные аргументы этой функции. Но и этот порядок может быть неоптимальным. Чтобы показать это, дополним пример следующим кодом:

\begin{minted}{ocaml}
module type SQRTABLE = sig
  type t
  val sqrt : t -> t
end;;

sqrt [S: SQRTABLE] = S.sqrt

implicit Squartable_float = {
    type t = float
    sqrt = Float.sqrt
}
\end{minted}

И попробуем обработать следующую функцию:

\begin{minted}{ocaml}
test x = (1.1 + x) + (sqrt x)
\end{minted}

Вывод неявного модуля для \mintinline{ocaml}{sqrt} даёт типизацию \mintinline{ocaml}{x : float}, и остальные неявные модули выводятся однозначно. Если же первый плюс будет обработан до обработки \mintinline{ocaml}{sqrt}, то результат будет неоднозначным.

Заметим, что проблема проявляется, даже если отказаться от требования уникальности и подставить любой из кандидатов: если в примере выше не угадать и подставить \mintinline{ocaml}{Int_Float}, а не \mintinline{ocaml}{Float_Float}, то после этого система проверки типов выдаст ошибку. Можно было бы после такой неудачной вставки откатиться к неоднозначному выводу и выбрать другой модуль, то есть осуществить поиск с возвратом (backtracking), но легко построить пример, на котором такое решение будет иметь экспоненциальную сложность.

Эта проблема проявляется во многих языках с неявными аргументами и выводом типов, например, в канонических структурах для Coq и в языке Arend. Из рассмотренных аналогов решение этой проблемы было обнаружено только в классах типов для Coq \cite{coq_typeclasses}. Как уже было описано, это решение опирается на возможность несогласованности, что нежелательно в неинтерактивном языке, поэтому решение из Coq неприменимо для решения задач данной работы.

\subsection{Алгоритм\footnote{Эта функциональность реализована в файле implicitsearch.ml, в функциях \href{https://github.com/trilis/1ml/blob/5b850e875e9ae06d3ce8e90a22cedbabcf0f33ca/implicitsearch.ml\#L191}{resolve\_step} и \href{https://github.com/trilis/1ml/blob/5b850e875e9ae06d3ce8e90a22cedbabcf0f33ca/implicitsearch.ml\#L227}{init\_state.}}}

Имеется набор неявных переменных, каждой из которых соответствует тип, возможно, зависящий от переменных вывода типов, то есть не полностью выведенный. В разных типах могут быть использованы одни и те же переменные. Если поиск выдаёт ошибку "нужный модуль не найден", следует сразу же завершиться с этой ошибкой. Но если поиск завершился с ошибкой "неоднозначность" или "поиск не завершается", имеется возможность, что с более конкретным типом (который будет получен после обработки других неявных переменных) поиск может корректно завершиться.  

Псевдокод для полной версии алгоритма приведён в алгоритме \ref{algo:order}. Опишем сначала упрощённую версию алгоритма. Будем запускать поиск для различных неявных переменных, пока не найдётся переменная, для которой поиск успешно завершится. Успешно завершённый поиск может дать новую информацию посредством конкретизации некоторых переменных вывода типа, поэтому снова будем запускать поиск для оставшихся неявных переменных. В конце либо все неявные переменные разрешены, либо ни одна из оставшихся неявных переменных не может быть однозначно выведена. Если существует некоторый порядок, позволяющий вывести все неявные переменные, то такой алгоритм найдёт его. Таким образом, мы решили задачу, однако крайне неэффективно, поэтому опишем несколько оптимизаций.

Ниже будут определены три приоритета. На каждом шаге алгоритма будем пробовать обработать неявную переменную с высшим приоритетом из всех оставшихся.

\begin{enumerate}
\item Высший приоритет присваивается тем неявным переменным, которые зависят только от переменных вывода типов, не встречающихся в типах других неявных переменных (в частности, высшим приоритетом обладают неявные переменные с полностью выведенным типом). Если такая "уникальная" неявная переменная появилась, нужно обработать её в первую очередь, ведь если их обработка завершилась с ошибкой, можно не надеяться на новую информацию от других неявных переменных, а следует завершить весь алгоритм;

\item Второй приоритет присваивается неявным переменным, которые не были обработаны ни разу;

\item Третий приоритет~--- неявным переменным, которые уже были безуспешно обработаны до этого, но с момента последней обработки которых некоторые переменные вывода типов, содержащиеся в типе этих неявных переменных, были выведены.
\end{enumerate}

В отличие от наивного квадратичного алгоритма, алгоритм с такими оптимизациями будет сначала обрабатывать (за оптимальное, линейное время) те неявные переменные, между которыми нет сложных зависимостей. То есть применение такого алгоритма строго лучше имеющегося в OCaml: тогда как решение, предложенное в этой работе, не замедлится на случаях, которые можно обрабатывать в любом порядке, оно позволяет дополнительно поддержать все случаи, работающие только при определённом порядке обработки.

В то же время, сложность вывода модулей со сложными зависимостями не сильно хуже. Пусть $N$~--- число модулей, которые должен вывести алгоритм, а $K$~--- сумма количеств переменных вывода типов по типам всех неявных модулей. Так как каждый запуск поиска происходит либо в первый раз для данной неявной переменной, либо после конкретизации переменных вывода типов, число запусков поиска имеет сложность $\mathcal{O}(N + K)$. Нужно заметить, что для большинства практических случаев эта сложность близка к линейной, так как чаще всего тип модуля зависит от небольшого числа переменных вывода типов.

Также были применены следующие эвристики, которые эффективно показали себя на имеющихся тестах:
\begin{itemize}
  \item Среди неявных переменных, которые не были обработаны ни разу, в первую очередь будем обрабатывать ту, которая зависит от меньшего числа переменных вывода типов. Мотивация следующая: если неявные переменным соответствуют модулям одного и того же типа (как это часто бывает), то больше шансов корректно обработать неявную переменную с более конкретным типом;
  \item Среди неявных переменных, которые уже были обработаны, в первую очередь будем обрабатывать ту, у которой с момента последней обработки больше переменных вывода типа было выведено.
\end{itemize}

Алгоритм можно ещё больше оптимизировать с помощью мемоизации, сохраняя некоторые результаты неудачного поиска. Например, можно сохранять информацию о ветках, в которых не найдено ни одного кандидата (в последующих запусках в эти ветки можно не заходить) или частичную информацию о переменных вывода типов (если стало известно, что какое-то подмножество переменных вывода типов принимает одинаковое значения для всех возможных кандидатов, то можно унифицировать эти переменные даже в случае безуспешного поиска). В данной работе были реализованы только самые примитивные из подобных техник, но подробное исследование мемоизации для данной задачи является интересным направлением дальнейшей работы.

\bigskip

\begin{megaalgorithm}
  \caption{Перебор неявных переменных}
  \label{algo:order}
\begin{algorithmic}
\State $V\gets$ множество неявных переменных
\State $V'\gets\varnothing$
\While{$|V \cup V'| \neq 0$}
  \State $V_{uniq} \gets \{v \mid v \in V \cup V' \textnormal{~и~} \forall v' \neq v \in V \textnormal{~типы~} v \textnormal{~и~} v' \textnormal{~независимы~}\}$
  \If{$|V_{uniq}| \neq 0$}
    \State $v \gets \textnormal{~любая из~} V_{uniq}$
    \State обработать $v$
    \If{обработка завершилась с ошибкой}
      \State завершиться с ошибкой
    \Else 
      \State $V \gets V \setminus \{v\}$
      \State $V' \gets V' \setminus \{v\}$
    \EndIf
  \ElsIf{$|V| \neq 0$}
    \State $v \gets \min V \textnormal{~по числу переменных в типе}$
    \State обработать $v$
    \If{успешно обработана}
      \State $V \gets V \setminus \{v\}$
    \ElsIf{обработка завершилась с ошибкой "нет кандидатов"}
      \State завершиться с ошибкой
    \Else
      \State ${V \gets V \setminus \{v\}}$
      \State ${V' \gets V' \cup \{v\}}$
    \EndIf
  \Else
    \State $V'_{new} \gets \{v \mid v \in V' \textnormal{~и с последней обработки~} v \textnormal{~получили о~} v \textnormal{~информацию}\}$
    \If{$|V'_{new}| = 0$}
      \State завершиться с ошибкой
    \Else
      \State $v \gets \max V'_{new} \textnormal{~по выведенным с последней обработки переменным в типе~} v$
      \State обработать $v$
      \If{успешно обработана}
        \State $V' \gets V' \setminus \{v\}$
      \ElsIf{обработка завершилась с ошибкой "нет кандидатов"}
        \State завершиться с ошибкой
      \EndIf
    \EndIf
  \EndIf
\EndWhile
\end{algorithmic}
\end{megaalgorithm}


\subsection{Выводы и результаты по главе}

Исследованы недостатки решений, обрабатывающих вывод модулей в фиксированном порядке. Был найден пример достаточно простого кода, который не работает в прототипе OCaml из-за этого недостатка. Предложен алгоритм, позволяющий корректно типизировать программу, если при каком-то порядке вывода эта программа корректно типизируется. Описанные оптимизации и эвристики делают предложенный алгоритм столь же эффективным на поддержанных в прототипе OCaml случаях, как и в прототипе для OCaml. При этом предложенный алгоритм способен корректно обрабатывать программы, не поддержанные в прототипе для OCaml, то есть предложенное решение является более полным.

\end{document}
