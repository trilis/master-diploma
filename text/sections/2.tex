\documentclass[../diploma.tex]{subfiles}
\begin{document}\label{sec:2}

В данной главе будут описаны важные детали решения: метод, которыми достигается проверка завершаемости, выбор времени, в который выводить накопившиеся модули, особенности реализации локальных неявных модулей. Далее, будет дана мотивация для добавления в язык синтаксической формы \mintinline{ocaml}{[_]}. Наконец, будут приведены примеры использования новой функциональности, предложенной в данной работе~--- неявных аргументов для функторов.

\subsection{Проверка завершаемости\footnote{Эта функциональность реализована в файле implicitsearch.ml, в функции \href{https://github.com/trilis/1ml/blob/5b850e875e9ae06d3ce8e90a22cedbabcf0f33ca/implicitsearch.ml\#L96}{termination\_check.}}}\label{termination}

Легко заметить, что описанный алгоритм поиска модуля может не завершаться. Рассмотрим следующий модуль:

\begin{minted}{ocaml}
implicit Show_id [Delegate: SHOW] = {
    type t = Delegate.t
    show = Delegate.show
}
\end{minted}

В присутствии такого модуля любая попытка вывести модуль будет бесконечно строить модуль вида \mintinline{ocaml}{Show_id [Show_id [Show_id ...]]}. Чтобы гарантировать завершаемость алгоритма, применим классическую эвристику. Будем проверять, что с момента последнего применения функтора, который алгоритм применяет в данный момент, была получена новая информация, то есть в данный момент решается более простая задача, чем решалась в предыдущий раз.

Понятие "задача стала проще" определим следующим образом: хотя бы одно ограничение на тип стало строго меньше, а остальные не увеличились. Под порядком "меньше" будем понимать простое структурное включение одного ограничения в другой. Ясно, что с таким ограничением поиск всегда будет завершаться.

Поясним эту идею на примере. При выводе неявного модуля для строкового представления списка списка чисел сначала будет искаться модуль с типом \mintinline{ocaml}{SHOW with}\\\mintinline{ocaml}{t = list list int}. После применения функтора \mintinline{ocaml}{Show_list} в качестве аргумента будет искаться модуль с типом \mintinline{ocaml}{SHOW with t = list int}, что структурно меньше, чем предыдущее ограничение, так что эта ветка поиска корректна. Если же вместо функтора \mintinline{ocaml}{Show_list} был подставлен функтор \mintinline{ocaml}{Show_id}, то снова бы искался модуль с типом \mintinline{ocaml}{SHOW with t = list list int}, и алгоритм возвращает ошибку "поиск не завершается".

Если было определено, что поиск может не завершаться, то следует вернуть ошибку, даже если в другой ветке поиска найден подходящий модуль, так как в таком случае нельзя гарантировать уникальность найденного модуля.

На самом деле, в некоторых случаях поиск может не завершаться, из-за того, что некоторые типы в ограничениях ещё не полностью выведены. При этом эти типы могут быть выведены после обработок некоторых других, завершающихся веток поиска. Поэтому, обнаружив ветку поиска, которая может не завершиться, следует не сразу заканчивать поиск с ошибкой, а обозначить эту ветку \textit{заблокированной} и попробовать продвинуться в других ветках. Только если все ветки либо полностью просмотрены, либо заблокированы, следует вернуть ошибку.

\subsection{Время вывода модулей}\label{time}

Напомним, что в некоторый момент накопившиеся неявные переменные будут выведены все вместе. Определим, в какой именно момент это будет происходить.

Главным соображением на этот счёт является следующее: чем дальше откладывается вывод модулей, тем больше типов будет выведено, следовательно, тем больше шансов на однозначность вывода модулей. Поэтому было бы разумно откладывать вывод модулей как можно дольше.

Если переменная вывода типов, связанная с неявным модулем, будет обобщена (generalized), то она превратится в типовую переменную, которую ни с чем нельзя унифицировать, что приведёт к ошибке. Руководствуясь этим, в решении для OCaml вывод модулей происходит непосредственно до обобщения типов, то есть, фактически, в момент обработки ближайшего к неявной аппликации let-определения.

В данной работе было реализовано следующее решение. Переменные вывода типов, связанные с неявными модулями, должны в результате унификации стать конкретными типами, если поиск модулей будет успешным. После обработки всей программы такие переменные не могут оставаться невыведенными~--- это бы значило, что поиск одного из неявных модуей был неудачен. Следовательно, обобщать эти переменные вообще не нужно. Будем помечать переменные, связанные с неявными модулями, и пропускать их при обобщении. 

Такое изменение делает выбор времени, в которое будут выводиться модули, более свободным. В частности, ничто не мешает выводить модули в самом конце типизации, получив максимально выведенные типы. В реализации этой работы было принято решение обрабатывать модули в момент достижения верхнеуровнего let-определения. Зависимости между неявными аппликациями из разных верхнеуровневых конструкций крайне редки, а предлагаемое решение позволяет независимо обрабатывать верхнеуровневые конструкции, что, на мой взгляд, является более естественным поведением.

\subsection{Локальные неявные модули}

Решение выводить модули в момент достижения верхнеуровнего let-определения поднимает небольшую проблему, связанную с неявными модулями, объявленными локально.

К примеру, рассмотрим следующую функцию, сортирующую (c помощью функции \mintinline{ocaml}{sort}, неявно принимающей компаратор) строки сначала лексикографически, а затем по длине:

\begin{minted}{ocaml}
sort_strings strs = 
    let by_lex = let implicit Sort_Lex = ... in sort strs in
    let by_len = let implicit Sort_Len = ... in sort strs in
    (by_lex, by_len)
\end{minted}

В этом примере оба неявных аргумента будут выведены при обработке верхнеуровнего let-определения функции \mintinline{ocaml}{sort_strings}. Но к этому моменту модули \mintinline{ocaml}{Sort_Lex} и \mintinline{ocaml}{Sort_Len} уже покинули область видимости и недоступны для поиска.

Получается, чтобы поддерживать неявную область видимости, требуется иметь доступ к контексту, который был доступен в момент неявной аппликации. Но хранить отдельную копию контекста для каждого контекста было бы расточительно по памяти. 

Будем поддерживать неявную область видимости в виде дерева, повторяющего структуру абстрактного синтаксического дерева, но хранящего только релевантные вершины. В этом дереве будут храниться неявные модули вместе со справочной информацией, такой как, например, доступные в контексте и используемые в неявных модулях типовые переменные. 

Для каждой неявной аппликации будем хранить вершину на таком сжатом дереве, которая соответствует её месту в синтаксическом дереве. Тогда, чтобы получить неявную область видимости для конкретной неявной аппликации, достаточно рассмотреть все модули на пути от корня до сохранённой для этой аппликации вершины. Заметим, что такая обработка на пути столь же эффективна, как обычный перебор всех модулей из контекста. 

\subsection{Синтаксис \mintinline{ocaml}{[_]}}\label{underscore}

Объясним мотивацию, стоящую за введением синтаксической формы \mintinline{ocaml}{[_]}, означающей "в этом месте необходимо вывести модуль". Дело в том, что алгоритм определяет, что модуль необходимо вывести, если обнаруживает неявную аппликацию. Тем не менее, существуют неявные выражения, в которых аппликация вовсе отсутствует. Рассмотрим, например, следующий интерфейс, определяющий нейтральный элемент, и модуль, реализующий этот интерфейс для сложения чисел:

\begin{minted}{ocaml}
type NEUTRAL = {
    type t
    neutral: t
}

implicit NeutralAdd = {
    type t = int
    neutral = 0
}
\end{minted}

И определим неявную функцию, возвращающую нейтральный элемент:

\begin{minted}{ocaml}
neutral [N : NEUTRAL] = N.neutral
\end{minted}

Но как использовать эту функцию? Действительно, так как тип этой функции~--- \mintinline{ocaml}{[N : NEUTRAL] -> N.t}, то нет явных аргументов, к которым можно применить эту функцию, чтобы появилась неявная аппликация. Тем не менее, в некоторых контекстах этот модуль можно вывести, например, в выражении \mintinline{ocaml}{5 + neutral}. Такое выражение не будет компилироваться в решении для OCaml, но аналогичные конструкции поддержаны в других языках, например, в Scala. Единственный способ применить такую функцию в решении для OCaml~--- передать ей явный аргумент, \mintinline{ocaml}{5 + neutral [NeutralAdd]}.

Проблема заключается в том, что с такими функциями не всегда ясно, что имел в виду программист: обращение к функции как есть, или вызов её с выводом неявного параметра. Особенно эта двусмысленность видна в выражениях вида \\\mintinline{ocaml}{let x = neutral in ...} или в случае передачи функции \mintinline{ocaml}{neutral} в качестве аргумента функции высшего порядка. 

В этой работе предлагается явное синтаксическое разделение двусмысленности семантики. В случае, если за неявной функцией, у которой нет явных аргументов, будет стоять токен \mintinline{ocaml}{[_]}, выражение будет трактоваться как неявная аппликация, и модуль будет выведен, в противном же случае функция будет трактоваться как есть. Это разумный компромисс: он позволяет не выписывать явно неявные модули для таких функций, ограничиваясь только явным указанием, что вывести нужно, при этом не усложняет ни систему проверки типов, ни читаемость кода.

\subsection{Неявные аргументы для функторов}

В решении для OCaml, тогда как модули могут использоваться в качестве неявных аргументов для \textit{функций}, использование модулей в качестве неявных аргументов для \textit{функторов} не поддерживается. Напомним, что в OCaml функции и функторы находятся на разных слоях языка, поэтому поддержка неявных аргументов для функторов в OCaml требует дополнительных теоретических исследований, и, вероятно, потребует дублирования функциональности. Так как в языке 1ML функции и функторы являются частными случаями одной и той же конструкции, можно минимальными усилиями переиспользовать решение, представленное в данной работе, чтобы поддержать неявные аргументы для функторов. Можно сказать, что в данной работе поддержан ad-hoc-полиморфизм на модульный уровнем. 

Опишем несколько случаев, в которых эта функциональность может быть полезна. Допустим, были определены два модуля, отвечаюшие за строковое представление списков: \mintinline{ocaml}{Show_list1} и \mintinline{ocaml}{Show_list2}. Их сигнатура одинакова, поэтому при применении неявной функции \mintinline{ocaml}{show} требуется выбрать модуль явно. Без поддержки неявных аргументов это делается следующим кодом:

\begin{minted}{ocaml}
show [Show_list1 [Show_pair [Show_string] [Show_int]]]
     (("hello" , 1) :: (("world", 2) :: nil))
\end{minted}

Заметим, что неоднозначность проявляется только при выборе \mintinline{ocaml}{Show_list1}, а вот часть \mintinline{ocaml}{Show_pair [Show_string] [Show_int]} может быть выведена автоматически. Поддержка неявных аргументов для функторов позволяет так переписать этот вызов:

\begin{minted}{ocaml}
show [Show_list1 [_]] (("hello" , 1) :: (("world", 2) :: nil))
\end{minted}

Отметим, что в этом примере была использована синтаксическая форма \mintinline{ocaml}{[_]}, введённая в предыдущем параграфе. Тогда как необходимость в ней для неявных функций появляется достаточно редко, для функторов она требуется достаточно часто, так как у неявных функторов все аргументы неявные.

В примере выше неявные аргументы для функторов применены в комбинации с неявными аргументами для функций. Неявные аргументы для функторов могут быть использованы и сами по себе, чтобы сделать короче код, применяющий функторы. Например, определим \mintinline{ocaml}{Set} как функтор с неявным аргументом:

\begin{minted}{ocaml}
Set [Elem : ORD] :> SET with (elem = Elem.t) = {
    (* ... *)
}
\end{minted}

Тогда не будет нужно явно передавать модуль, отвечающий за элементы \mintinline{ocaml}{Set}:

\begin{minted}{ocaml}
let S = Set [_] in S.add 3 (S.add 5 S.empty)
\end{minted}

\subsection{Выводы и результаты по главе}

Проверка завершаемости достигается стандартной эвристикой~--- проверяется, что задача с каждым вызовом становится проще. Из-за игнорирования переменных, связанных с неявными модулями, модули в этой работе выводятся позднее, чем в решении для OCaml, что приводит к получению большего числа информации о выводе типов. Такое решение поднимает новую проблему: к моменту вывода модули уже покинули область видимости. Эта задача решается с помощью поддерживания сжатого дерева из неявных модулей, симулирующего нужную часть контекста. Введена синтаксическая категория \mintinline{ocaml}{[_]} для поддержки неявных функций и функторов, у которых все аргументы неявные. Наконец, продемонстрированы неявные аргументы для функторов как совмещённые с неявными аргументами для функций, так и сами по себе.

\end{document}
